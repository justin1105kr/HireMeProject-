################################
# 정규표현식                     ##
# 일정한 규칙을 가진 문자열 표현     ##
# - 문자열 추출 / 규칙 판단        ##
# - re 모듈 사용                ##
# hit : 정규표현식 매치 객체       ##
# miss : 반환값 없음             ##
################################


###########################
# [자주 사용하는 문자 클래스]  ##
# [0-9] 또는 [a-zA-Z] 등은 무척 자주 사용하는 정규 표현식이다.
# ##############################################################################
# \d - 숫자와 매치, [0-9]와 동일한 표현식이다.
# \D - 숫자가 아닌 것과 매치, [^0-9]와 동일한 표현식이다.
# \s - whitespace 문자와 매치, [ \t\n\r\f\v]와 동일한 표현식이다. 맨 앞의 빈 칸은 공백문자(space)를 의미한다.
# \S - whitespace 문자가 아닌 것과 매치, [^ \t\n\r\f\v]와 동일한 표현식이다.
# \w - 문자+숫자(alphanumeric)와 매치, [a-zA-Z0-9_]와 동일한 표현식이다.
# \W - 문자+숫자(alphanumeric)가 아닌 문자와 매치, [^a-zA-Z0-9_]와 동일한 표현식이다.
# 대문자로 사용된 것은 소문자의 반대임을 추측할 수 있다.
##############################################################################

#####################
# re 모듈 메소드    ###
#######################################
# match()	    문자열의 '처음'부터 정규식과 매치되는지 조사한다.
# search()  	문자열 '전체'를 검색하여 정규식과 매치되는지 조사한다.
# findall() 	정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려준다.
# finditer()	정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려준다.
# compile(패턴)  정규표현식 패턴을 객체로 만듬 #
# 객체 = re.compile(패턴)
# 객체.match(문자열) / 객체.search(문자열)

#####################
# match 객체의 메서드 ##
#######################################
# group()	    매치된 문자열을 돌려준다.
# group(#)      매치된 문자열중 #번째 반환
# groups()      매치된 문자열을 튜플로 반환
# start()	    매치된 문자열의 시작 위치를 돌려준다.
# end()	        매치된 문자열의 끝 위치를 돌려준다.
# span()	    매치된 문자열의 (시작, 끝)에 해당하는 튜플을 돌려준다.


import re

p = re.compile('[a-z]+')
m = p.match('string goes here')
if m : # if match
    print('match : ', m.group())
else :
    print('no match')

# findall
result = p.findall('life is too short')
print(result) # ['life', 'is', 'too', 'short']

# finditer
# 매칭되는 반복되는 결과의 반복가능한 객체를 반환
# 각각의 객체는 match 객체 -> group을 이용하여 문자열 출력 가능
result = p.finditer('life is too short')
for r in result :
    print((r.group()).ljust(20), r)

############################
# group, group에 이름 짓기  ##
##################################################
# (?P<이름>표현식)
##################################################
print('testing\n****************')
m = re.match('(?P<func>[a-zA-Z_][a-zA-Z0-9_]+)\((?P<arg>\w+)\)', 'print(1234)')
print(m.group())
print('func : ',m.group('func'))
print('group(1) : ', m.group(1))
print('arg : ', m.group('arg'))
print('group(2) : ', m.group(2))
# \w+ = [a-zA-Z_][a-zA-Z0-9_]
print('****************\ntesting')



#########################################################
# 43.1 search : 문자열이 맨 앞에 오는 지, 뒤에 오는 지 판단하기  ##
#################################################################
# 1) ^패턴 : 패턴 문자열로 시작
# 2) 패턴$ : 패턴 문자열로 검색하고자 하는 문자열이 끝
# 3) 패턴1 | 패턴2 : 패턴1 or 패턴2 매치 확인 => 매칭되는 첫번째 문자열에 대한 match객체 반환
#################################################################
import re
print('^hello, hello world'.ljust(20), re.search('^hello', 'hello world') ) # 매치 객체 반환
print('world$, hello world'.ljust(20), re.search('world$', 'hello world') ) #
print('hello|jay, what up jay'.ljust(20), re.search('hello|jay', 'hello up jay') )


################################################
# 43.1.2 문자열 판단하기( match('패턴', 문자열) )     ##
########################################################
# re.match('패턴', '문자열')
# 반환값
########################################################
print('hello, hello world'.ljust(20), re.match('hello', 'hello world') )


#############################
# 43.2 범위, 문자 1개 확인    ##
##################################################
# [0-9]* : 0~9의 범위 0개 이상
# [0-9]+ : 0~9의 범위 1개 이상
# [a-zA-Z0-9]* : a~z, A~Z, 0~9 0개 이상
# [가-힣] : 한글 문자열 매칭 확인
# 문자* : 문자 0개 이상
# 문자+ : 문자 1개 이상
# ? : ? 앞의 문자(범위)가 0개 또는 1개 있는 지 판단 { 0, 1 }
# . : .가 있는 위치에 아무 문자(숫자)가 1개 있는 지 판단 { 1 }
##################################################
print('[0-9]+ 1234 '.ljust(20), re.match('[0-9]+', '1234') )
print('a+b, bc '.ljust(20), re.match('a+b', 'bc') )      # None 반환, bc -> a 없음
print('a*b, bc '.ljust(20), re.match('a*b', 'bc') )      # 객체 반환,
print('abc?, abd '.ljust(20), re.match('abc?', 'abd') )    # abd에서 c의 위치에 c 0개 -> 객체 반환
print('ab[0-9]?cd, ab3cd '.ljust(20), re.match('ab[0-9]?cd', 'ab3cd')) #
print('ab.d, abxd '.ljust(20), re.match('ab.d', 'abxd') )   # abxd에서 .의 위치에 문자 1개 -> 객체 반환
print('[a-zA-Z0-9]+, Hello1234'.ljust(30), re.match('[a-zA-Z0-9]+', 'Hello1234'))
print('[a-zA-Z0-9]+, hello1234'.ljust(30), re.match('[a-zA-Z0-9]+', 'hello1234')) # 해당 범위 내에 a-z, 0-9, A-Z 범위에 해당되는 문자들이 1개 이상 있음

############################
# 43.2.2 문자 갯수 확인하기   ##
##################################################
# 문자{갯수}
# 문자{갯수1, 갯수2} : 문자 갯수1~갯수2 매치
# (문자열){갯수} : '문자열'이 연속으로 정확히 몇 개 있는 지 판단할 때 사용
# (문자열){갯수1, 갯수2} : 문자열 갯수1개 ~ 갯수2 매치
# [0-9]{갯수}
# [0-9]{갯수1, 갯수2}
##################################################
print('h{3}, hhhelo'.ljust(20), re.match('h{3}', 'hhhelo'))
print('(hello){2}, hello~ hello~'.ljust(30), re.match('(hello){2}', 'hellohello~'))
# 휴대전화 형식 확인
print('[0-9]{3}-[0-9]{4}-[0-9]{4}, 010-1000-1000\n => ', re.match('[0-9]{3}-[0-9]{4}-[0-9]{4}', '010-1000-1000'))
print('[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}, 02-100-1000\n => ', re.match('[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}', '02-100-1000'))

############################################
# 43.2.4 특정 문자 범위에 포함되지 않는 지 확인하기 ##
##################################################
# [^범위]+ : 범위 내의 있는 문자를 제외한 문자들과 매치.
# [^범위]* : 범위 내의 있는 문자를 제외한 문자들과 매치.
# ^[범위]+ : 범위 내의 있는 문자로 시작하는 경우 매치
# [범위]*$ : 범위 내의 있는 문자로 끝나는 경우 매치
##################################################
print('[^A-Z]+, Hello'.ljust(20), re.match('[^A-Z]+', 'Hello'))
# 대문자 제외, 대문자가 1개라도 있으므로 매치 안됨
print('[^A-Z]+, hello'.ljust(20), re.match('[^A-Z]+', 'hello'))
print('[^A-Z]*, Hello'.ljust(20), re.match('[^A-Z]*', 'Hello'))
print('[^A-Z]*, hello'.ljust(20), re.match('[^A-Z]*', 'hello'))


##################################################
# 43.2.5 특수문자 / 공백 문자
# 1) \특수문자
# 2) 공백문자
# \s - whitespace 문자와 매치, [ \t\n\r\f\v]와 동일한 표현식이다. 맨 앞의 빈 칸은 공백문자(space)를 의미한다.
# \S - whitespace 문자가 아닌 것과 매치, [^ \t\n\r\f\v]와 동일한 표현식이다.
##################################################

