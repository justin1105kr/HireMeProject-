##########################
# 11. 시퀀스 자료형 활용하기 ##
################################################################################
# 시퀀스 자료형
# list, tuple, range,  str / bytes, bytearray
#
# tuple, range, 문자열 : 인덱스를 통해 내부 요소 변경 불가능
# (X) r[0] = 3,
# (X) hello = 'Hello, world!'   hello[0] = 'A'
################################################################################

####################################
# 11.1 시퀀스 자료형의 공통 기능 사용하기 ##
################################################################################
# 시퀀스 자료형의 가장 큰 특징은 공통된 동작과 기능을 제공한다는 점입니다.
# 시퀀스 자료형으로 만든 객체를 시퀀스 객체라고 하며,
# 시퀀스 객체에 들어있는 각 값을 요소(element)라고 부릅니다.
################################################################################

################################
# 11.1.1  특정 값이 있는지 확인하기 ##
# 값 in 시퀀스객체
# 값 not in 시퀀스객체
# 반환값 : True / False
################################################################################
# >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
# >>> 30 in a
# True
# >>> 100 in a
# False
################################################################################


############################
# 11.1.2  시퀀스 객체 연결하기 ##
################################################################################
# 퀀스 객체는 + 연산자를 사용하여 객체를 서로 연결하여 새 객체를 만들 수 있습니다.
# 시퀀스객체1 + 시퀀스객체2
# 단, 시퀀스 자료형 중에서 range는 + 연산자로 객체를 연결할 수 없습니다.
#
# >>> range(0, 10) + range(10, 20)
# Traceback (most recent call last):
#   File "<pyshell#1>", line 1, in <module>
#     range(0, 10) + range(10, 20)
# TypeError: unsupported operand type(s) for +: 'range' and 'range'
#
# 이때는 range를 리스트 또는 튜플로 만들어서 연결하면 됩니다.
#
# >>> list(range(0, 10)) + list(range(10, 20))
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# >>> tuple(range(0, 10)) + tuple(range(10, 20))
# (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)
################################################################################


############################
# 11.1.3  시퀀스 객체 반복하기 ##
################################################################################
# * 연산자는 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듭니다
# (0 또는 음수를 곱하면 빈 객체가 나오며 실수는 곱할 수 없습니다).
# 시퀀스객체 * 정수
# 정수 * 시퀀스객체
#
# >>> [0, 10, 20, 30] * 3
# [0, 10, 20, 30, 0, 10, 20, 30, 0, 10, 20, 30]
################################################################################


#########################################
# 11.2 시퀀스 객체의 요소 개수 구하기 ( len ) ##
################################################################################
# 시퀀스 객체에는 요소가 여러 개 들어있죠? 이 요소의 개수(길이)를 구할 때는
# len 함수를 사용합니다
#
# len(시퀀스객체)
#
################################################################################


############################
# 참고 | __getitem__ 메서드 ##
################################################################################
# 시퀀스 객체에서 [ ](대괄호)를 사용하면
# 실제로는 __getitem__ 메서드를 호출하여 요소를 가져옵니다.
# 따라서 다음과 같이 __getitem__ 메서드를 직접 호출하여 요소를 가져올 수도 있습니다.
#
# 시퀀스객체.__getitem__(인덱스)
# >>> a = [38, 21, 53, 62, 19]
# >>> a.__getitem__(1)
# 21
# __getitem__ 메서드는 '39.3 인덱스로 접근할 수 있는 이터레이터 만들기'에서 설명하겠습니다.
################################################################################


##############################
# 11.3.3  마지막 요소에 접근하기 ##
################################################################################
# ( len(a) - 1 )
################################################################################


############################
# 11.3.5  del로 요소 삭제하기 ##
################################################################################
# 이번에는 del로 시퀀스 객체의 요소를 삭제해보겠습니다.
# 요소 삭제는 다음과 같이 del 뒤에 삭제할 요소를 지정해주면 됩니다.
# 튜플은 삭제할 수 없습니다.
#
# del 시퀀스객체[인덱스]
# del 시퀀스객체[시작 인덱스 : 끝인덱스] # 슬라이스 이용하기
#
# >>> a = [38, 21, 53, 62, 19]
# >>> del a[2]
#
################################################################################


#######################
# 11.4 슬라이스 사용하기 ##
################################################################################
# 시퀀스 자료형은 슬라이스라는 기능을 자주 사용합니다.
# 슬라이스(slice)는 무엇인가의 일부를 잘라낸다는 뜻인데,
# 시퀀스 슬라이스도 말 그대로 시퀀스 객체의 일부를 잘라냅니다.
# 끝 인덱스는 가져오려는 범위에 포함되지 않습니다.
# 따라서 끝 인덱스는 실제로 가져오려는 인덱스보다 1을 더 크게 지정해야 합니다.
#
# 시퀀스객체[시작인덱스:끝인덱스]
#
# >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
# >>> a[0:4]     # 인덱스 0부터 3까지 잘라서 새 리스트를 만듦
# [0, 10, 20, 30]
################################################################################

##############################
# 11.4.2  인덱스 증가폭 사용하기 ##
################################################################################
# 슬라이스는 인덱스의 증가폭을 지정하여 범위 내에서 인덱스를 건너뛰며 요소를 가져올 수 있습니다.
#
# 시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭]
#
# >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
# >>> a[2:8:3]    # 인덱스 2부터 3씩 증가시키면서 인덱스 7까지 가져옴
# [20, 50]
################################################################################


#########################
# 11.4.3  인덱스 생략하기 ##
################################################################################
# 인덱스를 생략하는 방법은 시퀀스 객체의 길이를 몰라도 되기 때문에 자주 쓰이는 방식입니다.
#
# 시퀀스객체[:끝인덱스]
# 시퀀스객체[시작인덱스:]
#
# 시퀀스객체[:] # 리스트 전체
# a[:]와 같이 시작 인덱스와 끝 인덱스를 둘다 생략하면 리스트 전체를 가져옵니다
################################################################################


#######################################
# 11.4.4  인덱스를 생략하면서 증가폭 사용하기 ##
################################################################################
# 시퀀스객체[:끝인덱스:증가폭]
# 시퀀스객체[시작인덱스::증가폭]
#
# 시퀀스객체[::] # 리스트 전체
# 그냥 리스트 전체를 가져옵니다. 즉, a[:]와 a[::]는 결과가 같습니다.
#
#
# 참고 | 슬라이스의 인덱스 증가폭을 음수로 지정하면?
# >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
# >>> a[5:1:-1]
# [50, 40, 30, 20]
#
# 시작 인덱스와 끝 인덱스를 생략하면서 인덱스 증가폭을 -1로 지정하면
# 리스트를 반대로 뒤집습니다.
# >>> a[::-1]
# [90, 80, 70, 60, 50, 40, 30, 20, 10, 0]
################################################################################

###########################
# 참고 | slice 객체 사용하기 ##
##########################
# 파이썬에서는 slice 객체를 사용하여 시퀀스 객체(시퀀스 자료형으로 만든 변수)를 잘라낼 수도 있습니다.
#
# 슬라이스객체 = slice(끝인덱스)
# 슬라이스객체 = slice(시작인덱스, 끝인덱스)
# 슬라이스객체 = slice(시작인덱스, 끝인덱스, 인덱스증가폭)
# 시퀀스객체[슬라이스객체]
# 시퀀스객체.__getitem__(슬라이스객체)
#
# 다음과 같이 시퀀스 객체의 [ ](대괄호) 또는
# __getitem__ 메서드에 slice 객체를 넣어주면
# 지정된 범위만큼 잘라내서 새 객체를 만듭니다.
#
# >>> range(10)[slice(4, 7, 2)]
# range(4, 7, 2)
# >>> range(10).__getitem__(slice(4, 7, 2))
# range(4, 7, 2)
#
# 물론 slice 객체를 하나만 만든 뒤 여러 시퀀스 객체에 사용하는 방법도 가능합니다.
#
# >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
# >>> s = slice(4, 7)    # 인덱스 4부터 6까지 자르는 slice 객체 생성
# >>> a[s]
# [40, 50, 60]
# >>> r = range(10)
# >>> r[s]
# range(4, 7)
# >>> hello = 'Hello, world!'
# >>> hello[s]
# 'o, '
################################################################################


###############################
# 11.4.7  슬라이스에 요소 할당하기 ##
################################################################################
# 시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체
#
# >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
# >>> a[2:5] = ['a', 'b', 'c']    # 인덱스 2부터 4까지 값 할당
#
# 반면 할당할 요소 개수가 많으면 그만큼 리스트의 요소 개수도 늘어납니다.
#
# >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
# >>> a[2:5] = ['a', 'b', 'c', 'd', 'e'] # 인덱스 2부터 4까지 값 5개를 할당하여 요소의 개수가 늘어남
# >>> a
# [0, 10, 'a', 'b', 'c', 'd', 'e', 50, 60, 70, 80, 90]
#
# 튜플, range, 문자열은 슬라이스 범위를 지정하더라도 요소를 할당할 수 없습니다.
################################################################################

# 내장함수
# count(값)
# index(값)