#################################
# 39.1 반복 가능한 객체와 이터레이터  ##
##############################################################
# 이터레이터(Iterator) : 값을 차례로 꺼낼 수 있는 객체
# - 반복가능한 객체는 __iter__ 메소드로 이터레이터를 얻고, 이터레이터의 __next__ 메소드를 반복
# - 반복가능한 객체는 __iter__ 메소드를 사용할 수 있는 객체
# - 반복가능한 객체 != 이터레이터 객체

##############################################################
# 지연 평가(lazy evaluation) ##
############################
# 어떤 연속된 큰 값을 사용할 때, 미리 값을 만들면 메모리 성능에 불리함
# 따라서 필요한 시점에 연속된 값들을 만드는 방식

#########################################
# 객체가 이터레이터 프로토콜을 지원한다 의미     ##
# __iter__와 __next__ 메소드를 가진 객체   ##
# 즉, for 문 등 반복문에서 사용 가능한 객체   ##
##############################################################


###################################################
# 39.1 반복 가능한 객체 (Iterable Object)와 시퀀스 객체 ##
##############################################################
# 반복 가능한 객체 : 문자열 / 리스트 / 튜플 / range / 딕셔너리 / 세트
# => 반복 가능한 모든 객체
# 시퀀스 객체 : 문자열 / 리스트 / 튜플 / range
# => 반복 가능하고 순서가 정해져있는 객체
# 반복가능한 객체 ⊃ 시퀀스 객체

########################################
# 객체가 반복가능한 객체인지 확인하기          ##
# feat. dir(객체) : 사용 가능한 메소드 확인 ##
##############################################################
# dir(객체)를 통해 __iter__ 메서드를 사용할 수 있는 지 확인
# __iter__ 메소드를 사용할 수 있는 객체라면
# __iter__ 메소를 사용하여 이터레이터를 얻고 __next__()를 이용하여 요소를 계속 꺼내옴
# __next__() 실행 후 객체의 다음 요소가 없다면 StopIteration 예외 발생, 반복 종료

it = range(3).__iter__()
it.__next__() # 0
it.__next__() # 1
it.__next__() # 2
it.__next__() # StopIteration 에러
# Traceback (most recent call last):
#   File "<pyshell#5>", line 1, in <module>
#     it.__next__()
# StopIteration

#########################################
# 39.1.1 for문을 통해 보는 range 동작 과정  ##
##############################################################
# https://dojang.io/mod/page/view.php?id=2405
# (1) for i in range(3)
# (2) range(3).__iter__ range()에서 이터레이터를 얻음
# (3) range(3).__iter__().__next__() 반복
# (4) 다음 꺼내올 객체가 없을 경우
#     StopIteration 에러 발생, for문 반복 종료








