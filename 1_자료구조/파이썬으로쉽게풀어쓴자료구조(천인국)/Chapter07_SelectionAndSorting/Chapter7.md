### 구현 복잡도와 알고리즘 효율성에 따른 분류  
- 단순 / 비효율 : 삽입/선택/버블 정렬
- 복잡 / 효율 : 퀵/힙/병합/기수 정렬 

### 정렬의 대상인 레코드와 필드, 키의 개념  
- 레코드 : 정렬 시킬 대상
- 필드 : 원소
- 키(정렬키) : 현재 정렬하려는 대상 
![선택정렬 과정](./illustration_ch7/레코드필드키.Jpg)
  
### 안정성에 따른 분류  
- 안정성 : 입력 데이터에 돌일한 킷값을 갖는 레코드가 여러 개 존재할 경우, 정렬 후에도 이들의 상대적인 위치가 변하지않는 것
- __삽입/버블/병합 정렬__  

### 내부정렬 vs 외부 정렬  
- 내부 정렬 : 모든 데이터가 메모리에 올라와 있는 정렬
- 외부 정렬 : 외부 기억 장치의 데이터 중 일부만 메모리에 올려서 하는 정렬 

### 간단한 정렬 알고리즘  
1. 선택정렬 ( 안정성 X : 동일한 값을 갖는 값들의 상대적인 위치 변함 )
    - 가장 작은 숫자를 선택해서 앞(뒤)쪽으로 옮기는 정렬 
    - 오른쪽(왼쪽)에서 가장 작은 숫자를 선택하여 리스트의 맨 앞(뒤)로 이동하는 작업 반복  
    - 제자리 정렬 (in-place sorting) : 입력 배열 외에 추가적인 배열을 사용하지 않음
    ![선택정렬 과정](./illustration_ch7/선택정렬과정.png)
    ![선택정렬 과정](./illustration_ch7/선택정렬코드.jpeg)
    ![선택정렬 과정](./illustration_ch7/선택정렬과정.png)
    ![선택정렬 결과](./illustration_ch7/선택정렬결과.jpg)
    - 시간복잡도 : (n― l)+(n—2)+..·+l=n(n— 1)/2 = O(n²)
    
2. 삽입정렬 
    - 정렬이 안 된 부분의 값을 정렬된 부분에서 적절한 위치에 삽입하는 과정을 통한 정렬
    - 한 번의 삽입이 끝나면 정렬이 안된 부분의 항목수가 하나 줄어들고, 이 과정을 반복한다과.
    - 숫자를 끼워 넣는 과정에서 기존의 정렬되어 있는 곳의 항목들을 뒤쪽으로 이동시켜야하는 데, 이를 위해서 이 과정은 __배열의 뒤에서 시작한다__
    ![삽입정렬개념](./illustration_ch7/2삽입정렬개념.jpg)
    ![삽입정렬개념](./illustration_ch7/2삽입정렬과정.jpg)
             
    
    
    
    
