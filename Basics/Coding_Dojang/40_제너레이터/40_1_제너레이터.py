# 용량이 매우 큰 파일은 메모리에 한꺼번에 읽어서 처리하기가 힘듭니다.
# 따라서 대용량 데이터를 부분부분 처리해야 할 때 이렇게 제너레이터를 활용합니다.

##############################
# Unit 40. 제너레이터 사용하기   ##
########################################################
# 이터레이터 : __iter__, __next__ 메소드를 구현하여야 함. raise를 이용하여 StopIteration 예외 발생
# 제너레이터 : 이터레이터 생성 함수, __next__ 사용하 StopIteration 자동으로 발생.
# 이터레이터는 클래스에 __iter__, __next__ 또는 __getitem__ 메서드를 구현해야 하지만
# 제너레이터는 함수 안에서 yield라는 키워드만 사용하면 끝입니다.
# 그래서 제너레이터는 이터레이터보다 훨씬 간단하게 작성할 수 있습니다.
##############################################################

##############################################################
# 언제 사용?
# 결과 값을 출력할 때 사용하면 좋음.
# 혹은 파일을 읽을 때 !!
##############################################################


##############################################################
# 제너레이터 함수 동작 과정 이해  ##
############################
# 제너레이터 함수는 호출이 되면 실제로 실행되지 않고, 이터레이터(지연평가 사용)를 반환
# 내장함수 next를 호출할 때 마다 이터레이터는 제너레이터의 다음 yield 표현식으로 진행

# 1) 제너레이터 함수 실행
# 2) 제너레이터 yield 실행, 제너레이터 함수 실행 중 대기 상태
# 3) 함수 내부의 yield 값 반환, 제너레이터 함수 실행 제개
# 4) .. 반복
# 5) 끝 도달 시 StopIteration 예외 발생시켜 함수 종료
#    return 사용 시에도 StopIteration 발생시키고 함수 종료
#
# 제너레이터와 return
# 제너레이터 안에서 return에 반환값 지정시,
# StopIteration 예외의 에러메세지로 반환값 들어감
##############################################################


#############################
# 지연 평가(lazy evaluation) ##
##############################################################
# 어떤 연속된 큰 값을 사용할 때, 미리 값을 만들면 메모리 성능에 불리함
# 따라서 필요한 시점에 연속된 값들을 만드는 방식
##############################################################


def one_generator():
    yield 1
    return 'return에 지정한 값'


try:
    g = one_generator()
    next(g)
    next(g)
except StopIteration as e:
    print(e)  # return에 지정한 값


